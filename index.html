<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
    <title>Fuga dall'incubo</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://use.typekit.net/leb0fhi.css">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <script src="https://unpkg.com/@tensorflow/tfjs-core@3.7.0/dist/tf-core.min.js"></script>
    <script src="https://unpkg.com/@tensorflow/tfjs-backend-webgl@3.7.0/dist/tf-backend-webgl.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.0/dist/hand-pose-detection.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/xstate@4.37.2/lib/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.1/lib/p5.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }

        html,
        body {
            height: 100%;
        }

        body {
            width: 100%;
            margin: 0;
            padding: 0;
            background-image: url(IMG/Paesaggio-1.png);
            background-repeat: no-repeat;
            background-size: cover;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'VT323', monospace;
            font-size: 18pt;
            text-align: center;
        }

        .container {
            margin: 20px 20px;
            position: relative;
        }

        h1 {
            color: #fff;
            position: absolute;
            top: -5%;
            font-size: 100pt;
            background-color: #620000;

        }

        .paTakashit {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(3, 1fr);
            grid-column-gap: 0px;
            grid-row-gap: 0px;
        }

        #contenuto {
            background-color: rgba(0, 0, 0, 0);
            position: absolute;
            height: 60%;
            width: 45%;
            top: 20%;
            /* z-index: -1; */
        }

        #container {
            background-color: rgb(19, 19, 19);
            width: 100%;
            grid-area: 2 / 1 / 4 / span 2;
            justify-self: center;
        }

        #demo {
            position: absolute;
            margin: 0 5%;
            color: #ffdd00;
            font-size: 25pt;
            top: 35%;
        }

        #risposta {
            background-color: rgba(43, 43, 43, 0.643);
            grid-area: 2 / 1 / 1 / span 2;
            border: 1px solid white;
            transition: background-color 5s ease-in-out;
            color: #fff;

            /* transform: translate(-50%, -50%); */
            z-index: -1;
            position: relative;
        }

        #risposta.loading {
            animation: loading-animation 5s ease-in-out;
        }

        @keyframes loading-animation {
            0% {
                background-color: rgba(255, 255, 255, 0);
            }

            100% {
                background-color: rgb(255, 255, 255);
            }
        }

        canvas {
            display: block;
            margin: 0 auto;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .option {
            /* display: block; */
            display: none;
            padding: 10px;
            font-size: 16px;
            background-color: #b01717e5;
            color: #fff;
            border: 1px solid white;
            cursor: pointer;
            margin: 1% auto;
            width: 50%;

        }

        .option:hover {
            background-color: #001b38;
        }

        #stateMachine {
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            width: 200%;
        }

        .choices {
            margin-top: 20px;
        }

        .state {
            padding: 10px;
            margin-bottom: 10px;
        }

        .state.active {
            background-color: #007bff;
            color: #fff;
        }

        #cerchio {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border: 2px solid white;
            border-radius: 50%;
            background-color: transpaTakashit;

        }

        #cerchio.loaded {
            background-color: rgb(98, 225, 159);
        }
    </style>
</head>

<body>
    <h1>Fuga dall'incubo</h1>
    <div id="contenuto" class="paTakashit">
        <div id="container">
            <p id="demo"></p>
        </div>
        <div id="risposta" class="layer">
            <p style="margin-top: 1%;">Indica con la mano la tua risposta</p>
            <div id="cerchio"> </div>
        </div>
        <div class="choices">
            <div id="stateMachine" class="state"></div>
        </div>
    </div>
    <footer style="font-size: 14pt; color: white;white-space: pre; left: 50%; position: relative; top: 45%;">Music by <a
            style="color:#ffdd00"
            href="https://pixabay.com/it/users/gioelefazzeri-16466931/?tab=audio">GioeleFazzeri</a> from <a
            style="color:#ffdd00"
            href="https://pixabay.com//?utm_source=link-attribution&utm_medium=referral&utm_campaign=music&utm_content=15384">Pixabay</a>
        <audio id="audio1" src="/src/Musica.mp3" autoplay="">
            <script>
                a = document.getElementById('audio1');

                a.onended = function () { setTimeout("a.play()", 1000) }
            </script>
    </footer>
    <script>
        let capture;
        let detector;
        let selectedHand = null;
        let isHandInCircle = false; // Variabile per tracciare lo stato della mano nel cerchio
        const demoElement = document.getElementById("demo");
        const ratio = window.innerWidth / 16 * 9;

        async function setup() {
            const cerchioElement = document.getElementById('cerchio');
            createCanvas(window.innerWidth, ratio);
            capture = createCapture(VIDEO);
            capture.hide();
            detector = await createDetector();

        }
        function typeWriter(text, element) {
            element.innerHTML = ""; // Cancella il contenuto dell'elemento prima di digitare
            let i = 0;
            const speed = 0;

            function type() {
                if (i < text.length) {
                    element.innerHTML += text.charAt(i);
                    i++;
                    setTimeout(type, speed);
                }
            }
            type();
        }


        let lastDetectionTime = 0; // Variabile per tenere traccia dell'ultimo rilevamento della mano

        async function draw() {
            clear();
            background(0, 10);
            if (detector && capture.loadedmetadata) {
                const hands = await detector.estimateHands(capture.elt, { flipHorizontal: true });

                noStroke();
                for (let j = 0; j < hands.length; j++) {
                    const hand = hands[j];
                    const handedness = hand.handedness;
                    const middle = hand.keypoints[9];

                    let palmX = middle.x;
                    let palmY = middle.y;
                    let mappedPalmX = map(palmX, 0, capture.width, 0, window.innerWidth);
                    let mappedPalmY = map(palmY, 0, capture.height, 0, ratio);

                    if (hands.length == 2) {
                        fill("purple");
                    } else {
                        if (handedness === "Left") {
                            fill("blue");
                            selectedHand = hand;
                        } else if (handedness === "Right") {
                            fill("yellow");
                            selectedHand = hand;
                        }
                    }
                    circle(mappedPalmX, mappedPalmY, 50);

                    // Verifica se è trascorso abbastanza tempo dall'ultimo rilevamento della mano
                    const curTakashitTime = new Date().getTime();
                    const timeSinceLastDetection = curTakashitTime - lastDetectionTime;
                    if (timeSinceLastDetection >= 5000) { // 5000 millisecondi = 5 secondi
                        rispostaCerchio(handedness, selectedHand);
                        lastDetectionTime = curTakashitTime; // Aggiorna l'ultimo rilevamento della mano
                    }
                }
            }
        }


        rispostaCerchio = function (handedness, selectedHand) {
            if (!selectedHand) return;

            // Controlla se la mano selezionata è all'interno del cerchio centrale
            if (handedness === 'Right') {
                timer = this.setTimeout(() => {
                    machine.send('destra');
                    timer = 0;
                }, 2000);
            } else if (handedness === 'Left') {
                timer = this.setTimeout(() => {
                    machine.send('sinistra');
                    timer = 20000;
                }, 2000);
            }

        };

        function createMachine(config) {
            let curTakashitState = config.initial;
            let gameOver = false;

            function transition(state) {
                curTakashitState = state;
                Takashider();

                if (curTakashitState === "Muori" || curTakashitState === "Sopravvivi") {
                    gameOver = true;
                }
            }

            function Takashider() {
                const stateMachineEl = document.getElementById("stateMachine");
                stateMachineEl.innerHTML = "";

                const stateConfig = config.states[curTakashitState];
                const choices = Object.keys(stateConfig.on);

                const choicesEl = document.createElement("div");
                choicesEl.classList.add("choices");

                choices.forEach((choice) => {
                    const choiceDiv = document.createElement("div");
                    choiceDiv.textContent = choice;
                    choiceDiv.classList.add("option");
                    choiceDiv.addEventListener("gesture-detected", () => {
                        if (!gameOver) {
                            const targetState = stateConfig.on[choice].target;
                            transition(targetState);
                            console.log(targetState);
                            txt = targetState.testo;
                            typeWriter(txt, demoElement);

                            // Chiamare `machine.send()` con l'evento appropriato
                            machine.send(choice);
                        }
                    });

                    choicesEl.appendChild(choiceDiv);
                });

                stateMachineEl.appendChild(choicesEl);

                // Chiamare typeWriter con il testo di immissione dello stato corTakashite
                typeWriter(stateConfig.entry, demoElement);
            }

            Takashider();

            return {
                send: function (event) {
                    if (!gameOver) {
                        const textToType = "";
                        typeWriter(textToType, demoElement);
                        let stateConfig = config.states[curTakashitState];
                        let targetState = stateConfig.on[event].target;
                        transition(targetState);
                        console.log(targetState);
                        txt = targetState.testo;
                        typeWriter(txt, demoElement);

                        // Chiamare il metodo `dispatchEvent` per attivare l'evento gesto
                        const gestureEvent = new CustomEvent("gesture-detected", {
                            detail: {
                                gesture: event,
                            },
                        });
                        document.body.dispatchEvent(gestureEvent);
                    }
                },
            };
        }



        const machine = createMachine({
            id: "Gioco",
            initial: "Inizio",
            states: {
                "Inizio": {
                    entry: " Benvenuto nel gioco! Metti la mano destra all'interno del cerchio per incominciare a giocare!",
                    on: {
                        destra: {
                            target: "Prima scelta"
                        }
                    }
                },
                "Prima scelta": {
                    entry: " Takashi tornò a casa stanco dal lavoro. Notò subito che il suo telefono era completamente scarico. Mentre cercava il caricatore nella cucina, udì un rumore improvviso provenire dal salotto. Qualcuno era in casa.\nTakashi doveva decidere se cercare il caricatore (mano sinistra) per chiamare aiuto o nascondersi dietro la porta.(mano destra)",
                    on: {
                        destra: {
                            target: "Seconda scelta"
                        },
                        sinistra: {
                            target: "Muori"
                        }
                    }
                },
                "Seconda scelta": {
                    entry: " Takashi si nascose dietro la porta per non farsi notare dall'intruso.\nRiuscì camminando di soppiatto a raggiungere il salotto. Cosa fai? Ti nascondi sotto il tavolo o dietro il divano?",
                    on: {
                        destra: {
                            target: "Scappi"
                        },
                        sinistra: {
                            target: "Muori"
                        }
                    }
                },
                "Scappi": {
                    entry: "Hai deciso di nasconderti dietro il divano. L'assassino non nota Takashi ed esce dal salotto entrando in cucina, Takashi sfrutta l'opportunità per scappare di casa. Corre per la strada e s'imbatte in un vicolo",
                    on: {
                        destra: {
                            target: "Vicolo"
                        }
                    }
                },
                "Vicolo": {
                    entry: "Takashi si fermò per pTakashidere fiato ma non aveva molto tempo prima che il killer lo raggiungesse! Guardò davanti a sé e vide che aveva due opzioni, girare a sinistra o a destra",
                    on: {
                        sinistra: {
                            target: "Rete"
                        },
                        destra: {
                            target: "Strada"
                        }
                    }
                },
                "Rete": {
                    entry: "Takashi sceglie di andare a sinistra e si imbatte in una rete fatiscente che blocca il passaggio. Cosa fa?",
                    on: {
                        destra: {
                            target: "Principale"
                        },
                        sinistra: {
                            target: "Muori"
                        }
                    }
                },
                "Principale": {
                    entry: "Takashi ritorna nel vicolo principale e trova una piccola strada laterale che conduce a una stazione di servizio. Trova un telefono funzionante e chiama la polizia, ottenendo finalmente aiuto.",
                    on: {
                        destra: {
                            target: "Sopravvivi"
                        },
                    }
                },
                "Strada": {
                    entry: "Takashi decide di andare a destra e si imbatte in una strada deserta. Cosa fa?",
                    on: {
                        destra: {
                            target: "Takashi corre urlando e il killer lo insegue"
                        },
                        sinistra: {
                            target: "Due edifici"
                        }
                    }
                },
                "Takashi corre urlando e il killer lo insegue": {
                    entry: "Corre lungo la strada, sperando di trovare aiuto o un nascondiglio. Mentre Takashi corre lungo la strada deserta, il killer lo raggiunge e inizia una caccia spietata. Takashi deve fare delle scelte rapide per sfuggire, con esiti incerti.",
                    on: {
                        destra: {
                            target: "Muori"
                        },
                        sinistra: {
                            target: "Trova un gruppo di persone"
                        }
                    }
                },
                "Due edifici": {
                    entry: "Takashi cerca una via secondaria per evitare l'esposizione e continuare la fuga. Alla fine della strada si imbatte in due edifici: un vecchio magazzino e un edificio in costruzione",
                    on: {
                        destra: {
                            target: "Trovi un telefono e chiami la polizia"
                        },
                        sinistra: {
                            target: "Muori"
                        }
                    }
                },
                "Trova un gruppo di persone": {
                    entry: "Un gruppo di persone che hanno sentito le urla va incontro a Takashi per capire cosa è successo, grazie a loro sopravvivi e il killer scappa via.",
                    on: {
                        destra: {
                            target: "Sopravvivi"
                        }
                    }
                },
                "Trovi un telefono e chiami la polizia": {
                    entry: "All'interno del magazzino Takashi scopre che c'è un telefono, lo raggiunge e chiama immediatamente la polizia. Loro lo avvisano che ci vorrà un po' prima che lo raggiungano, nel frattempo gli indicano che deve rimanere nascosto e stare in guardia. Dove ti nascondi?",
                    on: {
                        destra: {
                            target: "Il killer guarda in giro"
                        },
                        sinistra: {
                            target: "Il killer guarda in giro ma non scende in cantina"
                        }
                    }
                },
                "Il killer guarda in giro": {
                    entry: "Takashi decide di rimanere fermo dietro agli scaffali del magazzino, sperando che il killer non lo trovi. Il killer entra nel magazzino e guarda in giro. Takashi emette un suono involontario che attira l'attenzione del killer. Il killer si avvicina. Cosa fai? Cambi nascondiglio o rimani fermo?",
                    on: {
                        destra: {
                            target: "Muori"
                        },
                        sinistra: {
                            target: "Sopravvivi"
                        }
                    }
                },
                "Il killer guarda in giro ma non scende in cantina": {
                    entry: "Takashi decide di scendere nella cantina del magazzino, sperando di trovare un nascondiglio più sicuro. Il killer entra nel magazzino e guarda in giro ma non scende in cantina. Successivamente se ne va. Takashi sopravvive",
                    on: {
                        destra: {
                            target: "Sopravvivi"
                        }
                    }
                },
                Muori: {
                    on: {
                        sinistra: {
                            target: "Inizio",
                            action: () => resetGame()
                        }
                    }
                },
                Sopravvivi: {
                    on: {
                        sinistra: {
                            target: "Inizio",
                            action: () => resetGame()
                        }
                    }
                }
            },
            predictableActionArguments: true,
            preserveActionOrder: true
        });
        function resetGame() {
            machine.reset();
            txt = '';
            typeWriter(txt, demoElement);
        }

        async function createDetector() {
            const mediaPipeConfig = {
                runtime: "mediapipe",
                modelType: "full",
                maxHands: 2,
                solutionPath: `https://cdn.jsdelivr.net/npm/@mediapipe/hands`,
            };
            return window.handPoseDetection.createDetector(window.handPoseDetection.SupportedModels.MediaPipeHands, mediaPipeConfig);
        }
    </script>

</body>


</html>
